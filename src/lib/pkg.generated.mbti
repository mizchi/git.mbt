// Generated using `moon info`, DON'T EDIT IT
package "mizchi/bit/lib"

import {
  "mizchi/bit",
}

// Values
pub fn add_paths(&@bit.FileSystem, &@bit.RepoFileSystem, String, Array[String]) -> Unit raise @bit.GitError

pub async fn add_paths_async(&@bit.FileSystem, &@bit.RepoFileSystem, String, Array[String]) -> Unit raise @bit.GitError

pub fn append_reflog(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, @bit.ObjectId, @bit.ObjectId, String, String, Int64, String, String) -> Unit raise @bit.GitError

pub fn apply_config_overrides(Map[String, RemoteConfig], Map[String, BranchConfig], Array[(String, String)]) -> Unit

pub fn apply_receive_pack(&@bit.FileSystem, &@bit.RepoFileSystem, String, ReceivePackRequest) -> ReceivePackResult raise @bit.GitError

pub fn apply_template(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit raise @bit.GitError

pub async fn apply_worktree_modes_from_commit(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, @bit.ObjectId) -> Unit raise @bit.GitError

pub fn build_receive_pack_advertisement(&@bit.RepoFileSystem, String, agent? : String) -> Bytes raise @bit.GitError

pub fn build_upload_pack_advertisement(&@bit.RepoFileSystem, String, agent? : String) -> Bytes raise @bit.GitError

pub fn build_upload_pack_config_with_overrides(&@bit.RepoFileSystem, String, Map[String, String]) -> UploadPackConfig

pub fn check_shorthand_ambiguity(String, (String) -> Bool) -> String?

pub fn checkout(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, detach? : Bool, update_worktree? : Bool, update_index? : Bool) -> @bit.ObjectId raise @bit.GitError

pub fn cherry_pick(&@bit.FileSystem, &@bit.RepoFileSystem, String, @bit.ObjectId, String, Int64) -> CherryPickResult raise @bit.GitError

pub fn clear_rebase_state(&@bit.FileSystem, &@bit.RepoFileSystem, String) -> Unit raise @bit.GitError

pub async fn clone_http(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, Bool) -> @bit.ObjectId? raise @bit.GitError

pub fn collect_commit_tree_only(ObjectDb, &@bit.RepoFileSystem, @bit.ObjectId) -> Array[@bit.PackObject] raise @bit.GitError

pub fn collect_diff_objects(ObjectDb, &@bit.RepoFileSystem, @bit.ObjectId, @bit.ObjectId) -> Array[@bit.PackObject] raise @bit.GitError

pub fn collect_local_branches(&@bit.RepoFileSystem, String) -> Array[String]

pub fn collect_loose_ref_ids(&@bit.RepoFileSystem, String, String, Map[String, @bit.ObjectId], String?) -> Unit

pub fn collect_packed_ref_ids(&@bit.RepoFileSystem, String, Map[String, @bit.ObjectId], String?) -> Unit

pub fn collect_reachable_objects(ObjectDb, &@bit.RepoFileSystem, @bit.ObjectId) -> Array[@bit.PackObject] raise @bit.GitError

pub fn collect_reachable_objects_from_commits(ObjectDb, &@bit.RepoFileSystem, Array[@bit.ObjectId]) -> Array[@bit.PackObject] raise @bit.GitError

pub fn collect_tree_blobs(ObjectDb, &@bit.RepoFileSystem, @bit.ObjectId) -> Array[@bit.ObjectId] raise @bit.GitError

pub fn collect_tree_files(ObjectDb, &@bit.RepoFileSystem, @bit.ObjectId) -> Map[String, TreeFileEntry] raise @bit.GitError

pub fn collect_tree_files_from_commit(ObjectDb, &@bit.RepoFileSystem, @bit.ObjectId) -> Map[String, TreeFileEntry] raise @bit.GitError

pub fn commit(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, String, Int64, committer? : String, committer_timestamp? : Int64) -> @bit.ObjectId raise @bit.GitError

pub fn commit_amend(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, String, Int64, committer? : String, committer_timestamp? : Int64) -> @bit.ObjectId raise @bit.GitError

pub fn config_has_remote_section(Array[ConfigBlock], String) -> Bool

pub fn config_strip_quotes(String) -> String

pub fn copy_tree(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit raise @bit.GitError

pub fn create_annotated_tag(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, @bit.ObjectId, String, String, Int64) -> Unit raise @bit.GitError

pub fn create_branch(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit raise @bit.GitError

pub fn create_branch_at(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, @bit.ObjectId) -> Unit raise @bit.GitError

pub fn create_lightweight_tag(&@bit.FileSystem, String, String, @bit.ObjectId) -> Unit raise @bit.GitError

pub fn create_reflog(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit raise @bit.GitError

pub fn create_worktree(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, String?, detach? : Bool, new_branch? : String?) -> Unit raise @bit.GitError

pub fn delete_branch(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, force? : Bool) -> Unit raise @bit.GitError

pub fn delete_reflog(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit raise @bit.GitError

pub fn delete_tag(&@bit.FileSystem, String, String) -> Unit raise @bit.GitError

pub fn detect_git_dir(&@bit.RepoFileSystem, String) -> (String, Bool)?

pub fn detect_protocol_version(Bytes) -> Int

pub fn diff_index(&@bit.RepoFileSystem, String) -> Array[DiffFile] raise @bit.GitError

pub fn diff_stat(Array[DiffFile]) -> Array[String]

pub fn diff_text(Array[DiffFile]) -> Array[String]

pub async fn diff_worktree(&@bit.RepoFileSystem, String) -> Array[DiffFile] raise @bit.GitError

pub fn fast_forward_to(&@bit.FileSystem, &@bit.RepoFileSystem, String, @bit.ObjectId) -> Unit raise @bit.GitError

pub fn find_tree_entry(ObjectDb, &@bit.RepoFileSystem, @bit.ObjectId, String) -> @bit.TreeEntry? raise @bit.GitError

pub fn format_remove_warning(Array[String]) -> String

pub fn gc_repo(&@bit.FileSystem, &@bit.RepoFileSystem, String) -> GcResult raise @bit.GitError

pub fn get_effective_remote_url(&@bit.RepoFileSystem, String) -> String?

pub fn get_protocol_version() -> Int

pub fn get_reflog_path(String, String) -> String

pub fn get_remote_url(&@bit.RepoFileSystem, String, String) -> String?

pub fn get_subdir_info(&@bit.RepoFileSystem, String) -> (String, String, String)?

pub fn get_subdir_tree_from_commit(ObjectDb, &@bit.RepoFileSystem, @bit.ObjectId, String) -> @bit.ObjectId? raise @bit.GitError

pub fn get_worktree_lock_reason(&@bit.RepoFileSystem, String, String) -> String? raise @bit.GitError

pub fn get_worktree_prunable_reason(&@bit.RepoFileSystem, String, String) -> String? raise @bit.GitError

pub fn init_repo(&@bit.FileSystem, String, default_branch? : String, bare? : Bool) -> Unit raise @bit.GitError

pub fn init_repo_with_options(&@bit.FileSystem, String, InitOptions) -> Unit raise @bit.GitError

pub fn is_bare_git_dir(String) -> Bool

pub fn is_branch_checked_out(&@bit.RepoFileSystem, String, String) -> String? raise @bit.GitError

pub fn is_ignored_path(&@bit.RepoFileSystem, String, String, Bool) -> Bool raise @bit.GitError

pub fn is_mirror_fetch_config(RemoteConfig) -> Bool

pub fn is_partial_clone(&@bit.RepoFileSystem, String) -> Bool

pub fn is_rebase_in_progress(&@bit.RepoFileSystem, String) -> Bool

pub fn is_remote_namespace(String, String) -> Bool

pub fn is_sparse_checkout_enabled(&@bit.RepoFileSystem, String) -> Bool

pub fn is_subdir_clone(&@bit.RepoFileSystem, String) -> Bool

pub fn is_valid_remote_name(String) -> Bool

pub fn legacy_remote_exists(&@bit.RepoFileSystem, String, String) -> Bool

pub fn list_branches(&@bit.RepoFileSystem, String) -> (HeadRef, Array[BranchInfo]) raise @bit.GitError

pub fn list_branches_text(&@bit.RepoFileSystem, String) -> Array[String] raise @bit.GitError

pub fn list_branches_verbose(&@bit.RepoFileSystem, String) -> Array[String] raise @bit.GitError

pub fn list_refs_with_ids(&@bit.RepoFileSystem, String, String?) -> Map[String, @bit.ObjectId]

pub fn list_remote_branches(&@bit.RepoFileSystem, String) -> Array[String]

pub fn list_remote_tracking_refs(&@bit.RepoFileSystem, String, String) -> Map[String, @bit.ObjectId]

pub fn list_remotes(&@bit.RepoFileSystem, String) -> Array[String]

pub fn list_remotes_verbose(&@bit.RepoFileSystem, String) -> Array[(String, String)]

pub fn list_tags(&@bit.RepoFileSystem, String) -> Array[String]

pub fn list_working_files(&@bit.RepoFileSystem, String) -> Array[String] raise @bit.GitError

pub async fn list_working_files_async(&@bit.RepoFileSystem, String) -> Array[String] raise @bit.GitError

pub fn list_worktrees(&@bit.RepoFileSystem, String) -> Array[WorktreeInfo] raise @bit.GitError

pub fn load_all_objects_from_fs(&@bit.RepoFileSystem, String) -> Array[@bit.PackObject] raise @bit.GitError

pub fn load_object_store_from_fs(&@bit.RepoFileSystem, String) -> @bit.ObjectStore raise @bit.GitError

pub fn load_rebase_state(&@bit.RepoFileSystem, String) -> RebaseState? raise @bit.GitError

pub fn lock_worktree(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, reason? : String?) -> Unit raise @bit.GitError

pub fn log_head(&@bit.RepoFileSystem, String, max_count? : Int) -> Array[LogEntry] raise @bit.GitError

pub fn log_head_oneline(&@bit.RepoFileSystem, String, max_count? : Int) -> Array[String] raise @bit.GitError

pub fn match_url_pattern(String, String) -> Bool

pub fn matches_sparse_pattern(String, Array[String]) -> Bool

pub fn merge(&@bit.FileSystem, &@bit.RepoFileSystem, String, @bit.ObjectId, String, String, Int64) -> MergeResult raise @bit.GitError

pub fn move_directory(&@bit.RepoFileSystem, &@bit.FileSystem, String, String) -> Unit

pub fn move_tree(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit raise @bit.GitError

pub fn move_tree_safe(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit raise @bit.GitError

pub fn move_worktree(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, String, force? : Bool) -> Unit raise @bit.GitError

pub fn mv_path(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, String, force? : Bool) -> Unit raise @bit.GitError

pub fn normalize_remote_branch_name(String) -> String

pub fn normalize_repo_path(String) -> String raise @bit.GitError

pub fn normalize_track_ref(String) -> String

pub fn parse_config_blocks(String) -> Array[ConfigBlock]

pub fn parse_config_kv(String) -> (String, String)?

pub fn parse_config_override_pairs() -> Array[(String, String)]

pub fn parse_config_overrides() -> Map[String, String]

pub fn parse_fetch_refspecs(Array[String]) -> Array[FetchRefspec]

pub fn parse_github_shorthand(String) -> GitHubShorthand?

pub fn parse_push_refspecs(Array[String]) -> Array[PushRefspec]

pub fn parse_receive_pack_request(Bytes) -> ReceivePackRequest raise @bit.GitError

pub fn parse_refspec_pair(String) -> (String, String)

pub fn parse_remote_config(String) -> (Map[String, RemoteConfig], Map[String, BranchConfig])

pub fn parse_section_header(String) -> (String, String?)

pub fn parse_upload_pack_request(Bytes) -> UploadPackRequest raise @bit.GitError

pub fn parse_upload_pack_request_v2(Bytes) -> UploadPackRequestV2 raise @bit.GitError

pub fn prune_repo(&@bit.FileSystem, &@bit.RepoFileSystem, String) -> PruneResult raise @bit.GitError

pub fn prune_worktrees(&@bit.FileSystem, &@bit.RepoFileSystem, String, dry_run? : Bool) -> Array[String] raise @bit.GitError

pub async fn pull_http(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, Bool, rebase? : Bool) -> @bit.ObjectId? raise @bit.GitError

pub async fn push_http(&@bit.RepoFileSystem, String, String, String) -> String raise @bit.GitError

pub async fn push_http_from_commit(&@bit.RepoFileSystem, String, String, @bit.ObjectId, String) -> String raise @bit.GitError

pub async fn push_http_tree_only(&@bit.RepoFileSystem, String, String, @bit.ObjectId, @bit.ObjectId, String) -> String raise @bit.GitError

pub fn read_config_bool(&@bit.RepoFileSystem, String, String, String) -> Bool?

pub fn read_config_content(&@bit.RepoFileSystem, String) -> String

pub fn read_config_value(&@bit.RepoFileSystem, String, String, String) -> String?

pub fn read_head_ref(&@bit.RepoFileSystem, String) -> HeadRef raise @bit.GitError

pub fn read_index_entries(&@bit.RepoFileSystem, String) -> Array[IndexEntry] raise @bit.GitError

pub fn read_local_remote_head_state(&@bit.RepoFileSystem, String, String) -> RemoteHeadState

pub fn read_promisor_remote(&@bit.RepoFileSystem, String) -> String?

pub fn read_reflog(&@bit.RepoFileSystem, String, String) -> Array[ReflogEntry] raise @bit.GitError

pub fn read_remote_head_branch(&@bit.RepoFileSystem, String) -> String?

pub fn read_repo_config(&@bit.RepoFileSystem, String) -> (Map[String, RemoteConfig], Map[String, BranchConfig])

pub fn read_sparse_patterns(&@bit.RepoFileSystem, String) -> Array[String] raise @bit.GitError

pub fn read_subdir_attributes(&@bit.RepoFileSystem, String) -> (String, String, String)?

pub fn rebase_abort(&@bit.FileSystem, &@bit.RepoFileSystem, String) -> Unit raise @bit.GitError

pub fn rebase_continue(&@bit.FileSystem, &@bit.RepoFileSystem, String) -> RebaseResult raise @bit.GitError

pub fn rebase_onto(&@bit.FileSystem, &@bit.RepoFileSystem, String, @bit.ObjectId) -> @bit.ObjectId raise @bit.GitError

pub fn rebase_skip(&@bit.FileSystem, &@bit.RepoFileSystem, String) -> RebaseResult raise @bit.GitError

pub fn rebase_start(&@bit.FileSystem, &@bit.RepoFileSystem, String, @bit.ObjectId) -> RebaseResult raise @bit.GitError

pub fn receive_pack(&@bit.FileSystem, &@bit.RepoFileSystem, String, Bytes) -> Bytes raise @bit.GitError

pub fn receive_pack_info_refs_response(&@bit.RepoFileSystem, String, String?, String, agent? : String) -> HttpResponse raise @bit.GitError

pub fn receive_pack_response(&@bit.FileSystem, &@bit.RepoFileSystem, String, String?, String, Bytes) -> HttpResponse raise @bit.GitError

pub fn reflog_exists(&@bit.RepoFileSystem, String, String) -> Bool

pub fn refspec_capture(String, String) -> String?

pub fn refspec_map_dst(String, String, String) -> String?

pub fn remote_set_branches(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, Array[String], Bool) -> Unit raise @bit.GitError

pub fn remote_skip_default_update(Array[ConfigBlock], String) -> Bool

pub fn remove_packed_ref(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit raise @bit.GitError

pub fn remove_packed_refs_with_prefix(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, String) -> Unit raise @bit.GitError

pub fn remove_ref_path(&@bit.FileSystem, &@bit.RepoFileSystem, String) -> Unit

pub fn remove_remote_refs(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit

pub fn remove_tree(&@bit.FileSystem, &@bit.RepoFileSystem, String) -> Unit

pub fn remove_worktree(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, force? : Bool) -> Unit raise @bit.GitError

pub fn rename_branch(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, String, force? : Bool) -> Unit raise @bit.GitError

pub fn rename_packed_refs_prefix(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, String, String, String) -> Unit raise @bit.GitError

pub fn render_config_blocks(Array[ConfigBlock]) -> String

pub fn repack_repo(&@bit.FileSystem, &@bit.RepoFileSystem, String) -> RepackResult? raise @bit.GitError

pub fn repair_worktree(&@bit.FileSystem, &@bit.RepoFileSystem, String, worktree_paths? : Array[String]) -> Array[String] raise @bit.GitError

pub fn reset(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, ResetMode) -> @bit.ObjectId raise @bit.GitError

pub fn resolve_gitdir(&@bit.RepoFileSystem, String) -> String

pub fn resolve_head_commit(&@bit.RepoFileSystem, String) -> @bit.ObjectId? raise @bit.GitError

pub fn resolve_local_repo_path(&@bit.RepoFileSystem, String, String) -> String?

pub fn resolve_ref(&@bit.RepoFileSystem, String, String) -> @bit.ObjectId? raise @bit.GitError

pub fn resolve_ref_for_subdir(&@bit.RepoFileSystem, String, String) -> @bit.ObjectId? raise @bit.GitError

pub async fn resolve_remote_ref_id(String, String) -> (@bit.ObjectId, String?)? raise @bit.GitError

pub fn restore_paths(&@bit.FileSystem, &@bit.RepoFileSystem, String, Array[String]) -> Unit raise @bit.GitError

pub fn rev_parse(&@bit.RepoFileSystem, String, String) -> @bit.ObjectId? raise @bit.GitError

pub fn rewrite_packed_refs(&@bit.FileSystem, &@bit.RepoFileSystem, String, (String) -> String?) -> Unit raise @bit.GitError

pub fn rm_paths(&@bit.FileSystem, &@bit.RepoFileSystem, String, Array[String], cached? : Bool, force? : Bool, recursive? : Bool) -> Unit raise @bit.GitError

pub fn set_config_key(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, String, String, String) -> Unit raise @bit.GitError

pub fn should_log_ref(&@bit.RepoFileSystem, String, String, Bool) -> (Bool, Bool) raise @bit.GitError

pub fn show_ref(&@bit.RepoFileSystem, String) -> Array[(String, @bit.ObjectId)] raise @bit.GitError

pub fn show_ref_text(&@bit.RepoFileSystem, String) -> Array[String] raise @bit.GitError

pub fn sort_branch_configs_by_name(Array[BranchConfig]) -> Unit

pub fn sort_strings_lex(Array[String]) -> Unit

pub fn sparse_checkout_add(&@bit.FileSystem, &@bit.RepoFileSystem, String, Array[String]) -> Unit raise @bit.GitError

pub fn sparse_checkout_disable(&@bit.FileSystem, &@bit.RepoFileSystem, String) -> Unit raise @bit.GitError

pub fn sparse_checkout_init(&@bit.FileSystem, &@bit.RepoFileSystem, String, cone? : Bool) -> Unit raise @bit.GitError

pub fn sparse_checkout_set(&@bit.FileSystem, &@bit.RepoFileSystem, String, Array[String]) -> Unit raise @bit.GitError

pub fn split_config_key(String, String) -> (String, String)?

pub fn split_whitespace_all(String) -> Array[String]

pub fn stash_apply(&@bit.FileSystem, &@bit.RepoFileSystem, String, Int, Bool) -> Unit raise @bit.GitError

pub fn stash_drop(&@bit.FileSystem, &@bit.RepoFileSystem, String, Int) -> Unit raise @bit.GitError

pub fn stash_list(&@bit.RepoFileSystem, String) -> Array[StashEntry] raise @bit.GitError

pub async fn stash_push(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, String, Int64) -> @bit.ObjectId? raise @bit.GitError

pub async fn status(&@bit.RepoFileSystem, String) -> Status raise @bit.GitError

pub async fn status_porcelain(&@bit.RepoFileSystem, String) -> Array[String] raise @bit.GitError

pub fn status_porcelain_from(Status) -> Array[String]

pub async fn status_text(&@bit.RepoFileSystem, String) -> String raise @bit.GitError

pub fn subdir_remove_dir(&@bit.RepoFileSystem, &@bit.FileSystem, String) -> Unit

pub fn switch_branch(&@bit.FileSystem, &@bit.RepoFileSystem, String, String, create? : Bool, checkout_files? : Bool) -> Unit raise @bit.GitError

pub fn tree_files_to_index(ObjectDb, &@bit.RepoFileSystem, Map[String, TreeFileEntry]) -> Array[IndexEntry] raise @bit.GitError

pub fn unlock_worktree(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit raise @bit.GitError

pub fn update_fetch_refspec(String, String, String) -> String

pub fn update_follow_remote_head(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit raise @bit.GitError

pub fn update_head_ref(&@bit.FileSystem, &@bit.RepoFileSystem, String, @bit.ObjectId) -> Unit raise @bit.GitError

pub fn update_subdir_base(&@bit.FileSystem, &@bit.RepoFileSystem, String, String) -> Unit

pub fn upload_pack(&@bit.RepoFileSystem, String, UploadPackRequest) -> Bytes raise @bit.GitError

pub fn upload_pack_v2(&@bit.RepoFileSystem, String, UploadPackRequestV2, UploadPackConfig) -> Bytes raise @bit.GitError

pub async fn working_files_cache(String) -> Array[String]? noraise

pub fn write_index_entries(&@bit.FileSystem, String, Array[IndexEntry]) -> Unit raise @bit.GitError

pub fn write_loose_object(&@bit.FileSystem, String, @bit.ObjectType, Bytes) -> @bit.ObjectId raise @bit.GitError

pub fn write_object_bytes(&@bit.FileSystem, String, @bit.ObjectId, Bytes) -> Unit raise @bit.GitError

pub fn write_sparse_patterns(&@bit.FileSystem, String, Array[String]) -> Unit raise @bit.GitError

pub fn write_subdir_attributes(&@bit.FileSystem, String, String, String, @bit.ObjectId) -> Unit

pub fn write_tree_from_index(&@bit.FileSystem, String, Array[IndexEntry], prefix? : String?) -> @bit.ObjectId raise @bit.GitError

pub fn write_tree_to_worktree(ObjectDb, &@bit.RepoFileSystem, &@bit.FileSystem, @bit.ObjectId, String) -> Unit raise @bit.GitError

pub fn write_worktree_from_files(ObjectDb, &@bit.FileSystem, &@bit.RepoFileSystem, String, String, Map[String, TreeFileEntry], remove_missing? : Bool) -> Unit raise @bit.GitError

// Errors

// Types and methods
pub(all) struct BranchConfig {
  name : String
  mut remote : String?
  mut merges : Array[String]
  mut rebase : Bool?
}

pub struct BranchInfo {
  name : String
  id : @bit.ObjectId
  current : Bool
}

pub struct CherryPickResult {
  status : CherryPickStatus
  commit_id : @bit.ObjectId?
  conflicts : Array[String]
}

pub enum CherryPickStatus {
  Success
  Conflict
}

pub(all) struct ConfigBlock {
  mut header : String?
  mut section : String?
  mut name : String?
  mut lines : Array[String]
}

pub struct DiffFile {
  path : String
  kind : DiffKind
  old_content : Bytes?
  new_content : Bytes?
  old_mode : Int?
  new_mode : Int?
}

pub enum DiffKind {
  Added
  Modified
  Deleted
}

pub(all) struct FetchRefspec {
  negative : Bool
  src : String
  dst : String
}

pub struct GcResult {
  pack : RepackResult?
  dangling : Array[@bit.ObjectId]
}

pub(all) enum GitHubShorthand {
  Repo(String, String?)
  Subdir(String, String, String?)
  File(String, String)
}
pub impl Eq for GitHubShorthand
pub impl Show for GitHubShorthand

pub enum HeadRef {
  Branch(String)
  Detached(@bit.ObjectId)
}

pub struct HttpResponse {
  status : Int
  headers : Map[String, String]
  body : Bytes
}

pub struct IndexEntry {
  path : String
  id : @bit.ObjectId
  mode : Int
  size : Int
  mtime_sec : Int
  mtime_nsec : Int
}
pub fn IndexEntry::new(String, @bit.ObjectId, Int, Int, mtime_sec? : Int, mtime_nsec? : Int) -> Self

pub(all) struct InitOptions {
  default_branch : String
  bare : Bool
  separate_git_dir : String?
  template_dir : String?
}
pub fn InitOptions::new() -> Self

pub struct LazyPackIndex {
  idx_path : String
  pack_path : String
  mut loaded : PackIndex?
}
pub fn LazyPackIndex::find_offset(Self, &@bit.RepoFileSystem, @bit.ObjectId) -> Int64? raise @bit.GitError
pub fn LazyPackIndex::find_offset_hex(Self, &@bit.RepoFileSystem, String) -> Int64? raise @bit.GitError
pub fn LazyPackIndex::get(Self, &@bit.RepoFileSystem) -> PackIndex raise @bit.GitError
pub fn LazyPackIndex::new(String, String) -> Self

pub struct LogEntry {
  id : @bit.ObjectId
  message : String
  author : String
  timestamp : Int64
}

pub struct MergeResult {
  status : MergeStatus
  commit_id : @bit.ObjectId?
  conflicts : Array[String]
}

pub enum MergeStatus {
  AlreadyUpToDate
  FastForward
  Merged
  Conflicted
}

pub struct ObjectDb {
  objects_dir : String
  loose_paths : Map[String, String]
  packs : Array[PackIndex]
  lazy_packs : Array[LazyPackIndex]
  pack_cache : Map[String, Bytes]
  pack_cache_order : Array[String]
  pack_cache_limit : Int
  mut prefer_packed : Bool
  mut saw_corrupt_pack : Bool
}
pub fn ObjectDb::get(Self, &@bit.RepoFileSystem, @bit.ObjectId) -> @bit.PackObject? raise @bit.GitError
pub fn ObjectDb::load(&@bit.RepoFileSystem, String) -> Self raise @bit.GitError
pub fn ObjectDb::load_lazy(&@bit.RepoFileSystem, String) -> Self raise @bit.GitError
pub fn ObjectDb::set_prefer_packed(Self, Bool) -> Unit

pub struct PackIndex {
  pack_path : String
  ids : Array[String]
  offsets : Array[Int64]
  version : Int
}
pub fn PackIndex::find_id_by_offset(Self, Int64) -> String?
pub fn PackIndex::find_offset(Self, @bit.ObjectId) -> Int64?
pub fn PackIndex::find_offset_hex(Self, String) -> Int64?

pub struct PromisorDb {
  db : ObjectDb
  git_dir : String
  promisor_remote : String?
  fetched : Map[String, Bool]
}
pub async fn PromisorDb::fetch_missing(Self, &@bit.FileSystem, Array[@bit.ObjectId]) -> Array[@bit.PackObject] raise @bit.GitError
pub async fn PromisorDb::fetch_one(Self, &@bit.FileSystem, @bit.ObjectId) -> @bit.PackObject? raise @bit.GitError
pub fn PromisorDb::get(Self, &@bit.RepoFileSystem, @bit.ObjectId) -> @bit.PackObject? raise @bit.GitError
pub async fn PromisorDb::get_or_fetch(Self, &@bit.RepoFileSystem, &@bit.FileSystem, @bit.ObjectId) -> @bit.PackObject? raise @bit.GitError
pub fn PromisorDb::get_promisor_remote(Self) -> String?
pub fn PromisorDb::has_local(Self, &@bit.RepoFileSystem, @bit.ObjectId) -> Bool raise @bit.GitError
pub fn PromisorDb::has_promisor(Self) -> Bool
pub fn PromisorDb::new(&@bit.RepoFileSystem, String, lazy_load? : Bool) -> Self raise @bit.GitError

pub struct PruneResult {
  pruned : Array[@bit.ObjectId]
}

pub(all) struct PushRefspec {
  force : Bool
  src : String
  dst : String
}

pub struct RebaseResult {
  status : RebaseStatus
  commit_id : @bit.ObjectId?
  conflicts : Array[String]
}

pub struct RebaseState {
  onto : @bit.ObjectId
  orig_head : @bit.ObjectId
  head_name : String
  todo : Array[@bit.ObjectId]
  done : Array[@bit.ObjectId]
  current : @bit.ObjectId?
  message : String
  author : String
  author_time : Int64
  author_tz : String
}

pub enum RebaseStatus {
  Complete
  Conflict
  NothingToRebase
}

pub struct ReceivePackRequest {
  updates : Array[RefUpdate]
  capabilities : Array[String]
  pack : Bytes
}

pub struct ReceivePackResult {
  updated : Array[String]
  rejected : Array[(String, String)]
}

pub struct RefUpdate {
  old_id : @bit.ObjectId
  new_id : @bit.ObjectId
  refname : String
}

pub struct ReflogEntry {
  old_id : @bit.ObjectId
  new_id : @bit.ObjectId
  author : String
  email : String
  timestamp : Int64
  timezone : String
  message : String
}

pub(all) struct RemoteConfig {
  mut urls : Array[String]
  mut pushurls : Array[String]
  mut fetch : Array[String]
  mut push : Array[String]
  mut promisor : Bool
  mut partial_clone_filter : String?
  mut mirror : Bool
  mut tagopt : String?
}

pub enum RemoteHeadState {
  Missing
  Detached(String)
  Symref(String)
  Other(String)
}

pub struct RepackResult {
  pack_id : @bit.ObjectId
  object_count : Int
  pack_bytes : Int
}

pub(all) enum ResetMode {
  Soft
  Mixed
  Hard
}

pub struct StashEntry {
  id : @bit.ObjectId
  message : String
}

pub struct Status {
  staged_added : Array[String]
  staged_modified : Array[String]
  staged_deleted : Array[String]
  unstaged_modified : Array[String]
  unstaged_deleted : Array[String]
  untracked : Array[String]
}

pub struct TreeFileEntry {
  id : @bit.ObjectId
  mode : Int
}

pub(all) struct UploadPackConfig {
  allow_filter : Bool
  blob_packfile_uri : String?
  allow_ref_in_want : Bool
}
pub fn UploadPackConfig::default() -> Self
pub fn UploadPackConfig::new(Bool, String?, Bool) -> Self

pub struct UploadPackRequest {
  wants : Array[@bit.ObjectId]
  haves : Array[@bit.ObjectId]
  capabilities : Array[String]
  done : Bool
  shallow : Array[@bit.ObjectId]
  deepen : Int?
}

pub struct UploadPackRequestV2 {
  command : String
  capabilities : Array[String]
  wants : Array[@bit.ObjectId]
  want_refs : Array[String]
  haves : Array[@bit.ObjectId]
  done : Bool
  filter : String?
  packfile_uris : String?
}

pub(all) struct WorktreeInfo {
  path : String
  head_id : @bit.ObjectId?
  branch : String?
  locked : Bool
  is_main : Bool
}

// Type aliases

// Traits

