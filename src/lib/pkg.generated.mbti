// Generated using `moon info`, DON'T EDIT IT
package "mizchi/git/lib"

import {
  "mizchi/git",
}

// Values
pub fn add_paths(&@git.FileSystem, &@git.RepoFileSystem, String, Array[String]) -> Unit raise @git.GitError

pub fn apply_receive_pack(&@git.FileSystem, &@git.RepoFileSystem, String, ReceivePackRequest) -> ReceivePackResult raise @git.GitError

pub fn build_receive_pack_advertisement(&@git.RepoFileSystem, String, agent? : String) -> Bytes raise @git.GitError

pub fn build_upload_pack_advertisement(&@git.RepoFileSystem, String, agent? : String) -> Bytes raise @git.GitError

pub fn checkout(&@git.FileSystem, &@git.RepoFileSystem, String, String, detach? : Bool, update_worktree? : Bool, update_index? : Bool) -> @git.ObjectId raise @git.GitError

pub fn cherry_pick(&@git.FileSystem, &@git.RepoFileSystem, String, @git.ObjectId, String, Int64) -> CherryPickResult raise @git.GitError

pub fn clear_rebase_state(&@git.FileSystem, &@git.RepoFileSystem, String) -> Unit raise @git.GitError

pub async fn clone_http(&@git.FileSystem, &@git.RepoFileSystem, String, String, Bool) -> @git.ObjectId? raise @git.GitError

pub fn collect_reachable_objects(ObjectDb, &@git.RepoFileSystem, @git.ObjectId) -> Array[@git.PackObject] raise @git.GitError

pub fn collect_reachable_objects_from_commits(ObjectDb, &@git.RepoFileSystem, Array[@git.ObjectId]) -> Array[@git.PackObject] raise @git.GitError

pub fn collect_tree_files(ObjectDb, &@git.RepoFileSystem, @git.ObjectId) -> Map[String, TreeFileEntry] raise @git.GitError

pub fn collect_tree_files_from_commit(ObjectDb, &@git.RepoFileSystem, @git.ObjectId) -> Map[String, TreeFileEntry] raise @git.GitError

pub fn commit(&@git.FileSystem, &@git.RepoFileSystem, String, String, String, Int64) -> @git.ObjectId raise @git.GitError

pub fn commit_amend(&@git.FileSystem, &@git.RepoFileSystem, String, String, String, Int64) -> @git.ObjectId raise @git.GitError

pub fn create_annotated_tag(&@git.FileSystem, &@git.RepoFileSystem, String, String, @git.ObjectId, String, String, Int64) -> Unit raise @git.GitError

pub fn create_branch(&@git.FileSystem, &@git.RepoFileSystem, String, String) -> Unit raise @git.GitError

pub fn create_branch_at(&@git.FileSystem, &@git.RepoFileSystem, String, String, @git.ObjectId) -> Unit raise @git.GitError

pub fn create_lightweight_tag(&@git.FileSystem, String, String, @git.ObjectId) -> Unit raise @git.GitError

pub fn delete_branch(&@git.FileSystem, &@git.RepoFileSystem, String, String, force? : Bool) -> Unit raise @git.GitError

pub fn delete_tag(&@git.FileSystem, String, String) -> Unit raise @git.GitError

pub fn diff_index(&@git.RepoFileSystem, String) -> Array[DiffFile] raise @git.GitError

pub fn diff_stat(Array[DiffFile]) -> Array[String]

pub fn diff_text(Array[DiffFile]) -> Array[String]

pub fn diff_worktree(&@git.RepoFileSystem, String) -> Array[DiffFile] raise @git.GitError

pub fn fast_forward_to(&@git.FileSystem, &@git.RepoFileSystem, String, @git.ObjectId) -> Unit raise @git.GitError

pub fn gc_repo(&@git.FileSystem, &@git.RepoFileSystem, String) -> GcResult raise @git.GitError

pub fn init_repo(&@git.FileSystem, String, default_branch? : String, bare? : Bool) -> Unit raise @git.GitError

pub fn is_ignored_path(&@git.RepoFileSystem, String, String, Bool) -> Bool raise @git.GitError

pub fn is_rebase_in_progress(&@git.RepoFileSystem, String) -> Bool

pub fn is_sparse_checkout_enabled(&@git.RepoFileSystem, String) -> Bool

pub fn list_branches(&@git.RepoFileSystem, String) -> (HeadRef, Array[BranchInfo]) raise @git.GitError

pub fn list_branches_text(&@git.RepoFileSystem, String) -> Array[String] raise @git.GitError

pub fn list_branches_verbose(&@git.RepoFileSystem, String) -> Array[String] raise @git.GitError

pub fn list_remote_branches(&@git.RepoFileSystem, String) -> Array[String]

pub fn list_tags(&@git.RepoFileSystem, String) -> Array[String]

pub fn list_working_files(&@git.RepoFileSystem, String) -> Array[String] raise @git.GitError

pub fn load_object_store_from_fs(&@git.RepoFileSystem, String) -> @git.ObjectStore raise @git.GitError

pub fn load_rebase_state(&@git.RepoFileSystem, String) -> RebaseState? raise @git.GitError

pub fn log_head(&@git.RepoFileSystem, String, max_count? : Int) -> Array[LogEntry] raise @git.GitError

pub fn log_head_oneline(&@git.RepoFileSystem, String, max_count? : Int) -> Array[String] raise @git.GitError

pub fn matches_sparse_pattern(String, Array[String]) -> Bool

pub fn merge(&@git.FileSystem, &@git.RepoFileSystem, String, @git.ObjectId, String, String, Int64) -> MergeResult raise @git.GitError

pub fn mv_path(&@git.FileSystem, &@git.RepoFileSystem, String, String, String, force? : Bool) -> Unit raise @git.GitError

pub fn parse_receive_pack_request(Bytes) -> ReceivePackRequest raise @git.GitError

pub fn parse_upload_pack_request(Bytes) -> UploadPackRequest raise @git.GitError

pub fn prune_repo(&@git.FileSystem, &@git.RepoFileSystem, String) -> PruneResult raise @git.GitError

pub async fn pull_http(&@git.FileSystem, &@git.RepoFileSystem, String, String, Bool, rebase? : Bool) -> @git.ObjectId? raise @git.GitError

pub async fn push_http(&@git.RepoFileSystem, String, String, String) -> String raise @git.GitError

pub fn read_head_ref(&@git.RepoFileSystem, String) -> HeadRef raise @git.GitError

pub fn read_index_entries(&@git.RepoFileSystem, String) -> Array[IndexEntry] raise @git.GitError

pub fn read_sparse_patterns(&@git.RepoFileSystem, String) -> Array[String] raise @git.GitError

pub fn rebase_abort(&@git.FileSystem, &@git.RepoFileSystem, String) -> Unit raise @git.GitError

pub fn rebase_continue(&@git.FileSystem, &@git.RepoFileSystem, String) -> RebaseResult raise @git.GitError

pub fn rebase_onto(&@git.FileSystem, &@git.RepoFileSystem, String, @git.ObjectId) -> @git.ObjectId raise @git.GitError

pub fn rebase_skip(&@git.FileSystem, &@git.RepoFileSystem, String) -> RebaseResult raise @git.GitError

pub fn rebase_start(&@git.FileSystem, &@git.RepoFileSystem, String, @git.ObjectId) -> RebaseResult raise @git.GitError

pub fn receive_pack(&@git.FileSystem, &@git.RepoFileSystem, String, Bytes) -> Bytes raise @git.GitError

pub fn receive_pack_info_refs_response(&@git.RepoFileSystem, String, String?, String, agent? : String) -> HttpResponse raise @git.GitError

pub fn receive_pack_response(&@git.FileSystem, &@git.RepoFileSystem, String, String?, String, Bytes) -> HttpResponse raise @git.GitError

pub fn repack_repo(&@git.FileSystem, &@git.RepoFileSystem, String) -> RepackResult? raise @git.GitError

pub fn reset(&@git.FileSystem, &@git.RepoFileSystem, String, String, ResetMode) -> @git.ObjectId raise @git.GitError

pub fn resolve_head_commit(&@git.RepoFileSystem, String) -> @git.ObjectId? raise @git.GitError

pub fn resolve_ref(&@git.RepoFileSystem, String, String) -> @git.ObjectId? raise @git.GitError

pub fn restore_paths(&@git.FileSystem, &@git.RepoFileSystem, String, Array[String]) -> Unit raise @git.GitError

pub fn rev_parse(&@git.RepoFileSystem, String, String) -> @git.ObjectId? raise @git.GitError

pub fn rm_paths(&@git.FileSystem, &@git.RepoFileSystem, String, Array[String], cached? : Bool, force? : Bool, recursive? : Bool) -> Unit raise @git.GitError

pub fn show_ref(&@git.RepoFileSystem, String) -> Array[(String, @git.ObjectId)] raise @git.GitError

pub fn show_ref_text(&@git.RepoFileSystem, String) -> Array[String] raise @git.GitError

pub fn sparse_checkout_add(&@git.FileSystem, &@git.RepoFileSystem, String, Array[String]) -> Unit raise @git.GitError

pub fn sparse_checkout_disable(&@git.FileSystem, &@git.RepoFileSystem, String) -> Unit raise @git.GitError

pub fn sparse_checkout_init(&@git.FileSystem, &@git.RepoFileSystem, String, cone? : Bool) -> Unit raise @git.GitError

pub fn sparse_checkout_set(&@git.FileSystem, &@git.RepoFileSystem, String, Array[String]) -> Unit raise @git.GitError

pub fn stash_apply(&@git.FileSystem, &@git.RepoFileSystem, String, Int, Bool) -> Unit raise @git.GitError

pub fn stash_drop(&@git.FileSystem, &@git.RepoFileSystem, String, Int) -> Unit raise @git.GitError

pub fn stash_list(&@git.RepoFileSystem, String) -> Array[StashEntry] raise @git.GitError

pub fn stash_push(&@git.FileSystem, &@git.RepoFileSystem, String, String, String, Int64) -> @git.ObjectId? raise @git.GitError

pub fn status(&@git.RepoFileSystem, String) -> Status raise @git.GitError

pub fn status_porcelain(&@git.RepoFileSystem, String) -> Array[String] raise @git.GitError

pub fn status_porcelain_from(Status) -> Array[String]

pub fn status_text(&@git.RepoFileSystem, String) -> String raise @git.GitError

pub fn switch_branch(&@git.FileSystem, &@git.RepoFileSystem, String, String, create? : Bool, checkout? : Bool) -> Unit raise @git.GitError

pub fn tree_files_to_index(ObjectDb, &@git.RepoFileSystem, Map[String, TreeFileEntry]) -> Array[IndexEntry] raise @git.GitError

pub fn update_head_ref(&@git.FileSystem, &@git.RepoFileSystem, String, @git.ObjectId) -> Unit raise @git.GitError

pub fn upload_pack(&@git.RepoFileSystem, String, UploadPackRequest) -> Bytes raise @git.GitError

pub fn write_index_entries(&@git.FileSystem, String, Array[IndexEntry]) -> Unit raise @git.GitError

pub fn write_loose_object(&@git.FileSystem, String, @git.ObjectType, Bytes) -> @git.ObjectId raise @git.GitError

pub fn write_object_bytes(&@git.FileSystem, String, @git.ObjectId, Bytes) -> Unit raise @git.GitError

pub fn write_sparse_patterns(&@git.FileSystem, String, Array[String]) -> Unit raise @git.GitError

pub fn write_tree_from_index(&@git.FileSystem, String, Array[IndexEntry], prefix? : String?) -> @git.ObjectId raise @git.GitError

pub fn write_worktree_from_files(ObjectDb, &@git.FileSystem, &@git.RepoFileSystem, String, String, Map[String, TreeFileEntry], remove_missing? : Bool) -> Unit raise @git.GitError

// Errors

// Types and methods
pub struct BranchInfo {
  name : String
  id : @git.ObjectId
  current : Bool
}

pub struct CherryPickResult {
  status : CherryPickStatus
  commit_id : @git.ObjectId?
  conflicts : Array[String]
}

pub enum CherryPickStatus {
  Success
  Conflict
}

pub struct DiffFile {
  path : String
  kind : DiffKind
  old_content : Bytes?
  new_content : Bytes?
}

pub enum DiffKind {
  Added
  Modified
  Deleted
}

pub struct GcResult {
  pack : RepackResult?
  dangling : Array[@git.ObjectId]
}

pub enum HeadRef {
  Branch(String)
  Detached(@git.ObjectId)
}

pub struct HttpResponse {
  status : Int
  headers : Map[String, String]
  body : Bytes
}

pub struct IndexEntry {
  path : String
  id : @git.ObjectId
  mode : Int
  size : Int
}

pub struct LogEntry {
  id : @git.ObjectId
  message : String
  author : String
  timestamp : Int64
}

pub struct MergeResult {
  status : MergeStatus
  commit_id : @git.ObjectId?
  conflicts : Array[String]
}

pub enum MergeStatus {
  AlreadyUpToDate
  FastForward
  Merged
  Conflicted
}

pub struct ObjectDb {
  loose_paths : Map[String, String]
  packs : Array[PackIndex]
}
pub fn ObjectDb::get(Self, &@git.RepoFileSystem, @git.ObjectId) -> @git.PackObject? raise @git.GitError
pub fn ObjectDb::load(&@git.RepoFileSystem, String) -> Self raise @git.GitError

pub struct PackIndex {
  pack_path : String
  ids : Array[String]
  offsets : Array[Int64]
}
pub fn PackIndex::find_offset(Self, @git.ObjectId) -> Int64?
pub fn PackIndex::find_offset_hex(Self, String) -> Int64?

pub struct PruneResult {
  pruned : Array[@git.ObjectId]
}

pub struct RebaseResult {
  status : RebaseStatus
  commit_id : @git.ObjectId?
  conflicts : Array[String]
}

pub struct RebaseState {
  onto : @git.ObjectId
  orig_head : @git.ObjectId
  head_name : String
  todo : Array[@git.ObjectId]
  done : Array[@git.ObjectId]
  current : @git.ObjectId?
  message : String
  author : String
  author_time : Int64
  author_tz : String
}

pub enum RebaseStatus {
  Complete
  Conflict
  NothingToRebase
}

pub struct ReceivePackRequest {
  updates : Array[RefUpdate]
  capabilities : Array[String]
  pack : Bytes
}

pub struct ReceivePackResult {
  updated : Array[String]
  rejected : Array[(String, String)]
}

pub struct RefUpdate {
  old_id : @git.ObjectId
  new_id : @git.ObjectId
  refname : String
}

pub struct RepackResult {
  pack_id : @git.ObjectId
  object_count : Int
  pack_bytes : Int
}

pub(all) enum ResetMode {
  Soft
  Mixed
  Hard
}

pub struct StashEntry {
  id : @git.ObjectId
  message : String
}

pub struct Status {
  staged_added : Array[String]
  staged_modified : Array[String]
  staged_deleted : Array[String]
  unstaged_modified : Array[String]
  unstaged_deleted : Array[String]
  untracked : Array[String]
}

pub struct TreeFileEntry {
  id : @git.ObjectId
  mode : Int
}

pub struct UploadPackRequest {
  wants : Array[@git.ObjectId]
  haves : Array[@git.ObjectId]
  capabilities : Array[String]
  done : Bool
}

// Type aliases

// Traits

