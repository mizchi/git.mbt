// Generated using `moon info`, DON'T EDIT IT
package "mizchi/bit/x/kv"

import {
  "mizchi/bit",
  "mizchi/bit/lib",
}

// Values

// Errors

// Types and methods
pub(all) struct GitObject {
  id : @bit.ObjectId
  obj_type : @bit.ObjectType
  data : Bytes
}

pub(all) enum GossipMessage {
  Announce(GossipState)
  WantObjects(Array[@bit.ObjectId])
  HaveObjects(Array[GitObject])
  SyncRequest(NodeId, @bit.ObjectId)
  SyncResponse(Array[GitObject], @bit.ObjectId)
}

pub(all) struct GossipState {
  node_id : NodeId
  head : @bit.ObjectId
  clock : VectorClock
  timestamp : Int64
}

pub struct Kv {
  node_id : NodeId
  tree : &@lib.WorkingTree
  store : &@lib.ObjectStore
  mut clock : VectorClock
  mut head : @bit.ObjectId
  peers : Map[String, PeerInfo]
  pending_objects : Map[String, GitObject]
}
pub fn Kv::add_peer(Self, PeerInfo) -> Unit
pub fn Kv::apply_pending_objects(Self) -> Int raise @bit.GitError
pub fn Kv::clock(Self) -> VectorClock
pub fn Kv::commit(Self, String, Int64) -> @bit.ObjectId raise @bit.GitError
pub fn Kv::delete(Self, String) -> Unit
pub fn Kv::get(Self, String) -> Bytes?
pub fn Kv::get_gossip_state(Self, Int64) -> GossipState
pub fn Kv::get_peers(Self) -> Array[PeerInfo]
pub fn Kv::handle_gossip(Self, GossipMessage, Int64) -> GossipMessage?
pub fn Kv::has(Self, String) -> Bool
pub fn Kv::has_pending_objects(Self) -> Bool
pub fn Kv::head(Self) -> @bit.ObjectId
pub fn Kv::is_dirty(Self) -> Bool
pub fn Kv::list(Self, String) -> Array[String]
pub fn Kv::list_recursive(Self, String) -> Array[String]
pub fn Kv::merge(Self, @bit.ObjectId, VectorClock, MergeStrategy, Int64) -> MergeResult raise @bit.GitError
pub fn Kv::new(NodeId, &@lib.WorkingTree, &@lib.ObjectStore, @bit.ObjectId) -> Self
pub fn Kv::node_id(Self) -> NodeId
pub fn Kv::pending_object_count(Self) -> Int
pub fn Kv::remove_peer(Self, NodeId) -> Bool
pub fn Kv::rollback(Self) -> Unit
pub fn Kv::select_gossip_peers(Self, Int, Int64) -> Array[PeerInfo]
pub fn Kv::serialize_snapshot(Self) -> SerializedSnapshot
pub fn Kv::set(Self, String, Bytes) -> Unit
pub fn Kv::set_string(Self, String, String) -> Unit

pub(all) struct KvConfig {
  node_id : NodeId
  max_peers : Int
  gossip_interval_ms : Int
  sync_batch_size : Int
}
pub fn KvConfig::default(NodeId) -> Self

pub(all) enum MergeResult {
  NoOp
  FastForward(@bit.ObjectId)
  Merged(@bit.ObjectId, Array[String])
  Conflict(Array[String])
}

pub(all) enum MergeStrategy {
  LastWriteWins
  KeepBoth
  Custom((Bytes, Bytes) -> Bytes)
}

pub(all) struct NodeId {
  id : String
}
pub fn NodeId::new(String) -> Self
pub impl Eq for NodeId
pub impl Hash for NodeId
pub impl Show for NodeId

pub(all) struct PeerInfo {
  node_id : NodeId
  last_seen : Int64
  head : @bit.ObjectId
  endpoint : String
}

pub(all) struct SerializationStats {
  total_bytes : Int
  object_count : Int
  commit_count : Int
  tree_count : Int
  blob_count : Int
  blob_bytes : Int
}

pub(all) struct SerializedObject {
  id : Bytes
  obj_type : Int
  data : Bytes
}

pub(all) struct SerializedSnapshot {
  version : Int
  node_id : String
  head : Bytes
  clock : Array[(String, Int64)]
  objects : Array[SerializedObject]
}
pub fn SerializedSnapshot::byte_size(Self) -> Int
pub fn SerializedSnapshot::from_bytes(Bytes) -> Self
pub fn SerializedSnapshot::stats(Self) -> SerializationStats
pub fn SerializedSnapshot::to_bytes(Self) -> Bytes

pub(all) struct SyncResult {
  objects_sent : Int
  objects_received : Int
  conflicts : Array[String]
  new_head : @bit.ObjectId
}

pub(all) struct VectorClock {
  clocks : Map[String, Int64]
}
pub fn VectorClock::compare(Self, Self) -> Int
pub fn VectorClock::increment(Self, NodeId) -> Self
pub fn VectorClock::merge(Self, Self) -> Self
pub fn VectorClock::new() -> Self

// Type aliases

// Traits

